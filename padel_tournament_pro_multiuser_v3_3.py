# padel_tournament_pro_multiuser_v3_3.py# Versión 3.3 — Correcciones de sintaxis, logo integrado y todas las funcionalidades solicitadas.import streamlit as stimport pandas as pdimport numpy as npfrom itertools import combinationsimport randomfrom datetime import datetime, dateimport jsonfrom pathlib import Pathimport hashlibimport uuidfrom typing import Dict, Any, List, Optional, Tuplefrom io import BytesIO# Dependencias opcionales para PDFtry:    from reportlab.lib.pagesizes import A4    from reportlab.lib import colors    from reportlab.lib.units import cm    from reportlab.platypus import SimpleDocTemplate, Table, TableStyle, Paragraph, Spacer    from reportlab.lib.styles import getSampleStyleSheet    REPORTLAB_OK = Trueexcept Exception:    REPORTLAB_OK = Falsest.set_page_config(page_title="Torneo de Pádel — Multiusuario v3.3", layout="wide")# ----------------------------# Logo (SVG inline) — esquina superior izquierda# ----------------------------PRIMARY_BLUE = "#0D47A1"LIME_GREEN  = "#AEEA00"DARK_BLUE   = "#082D63"def brand_svg(width_px: int = 220) -> str:    return f'''<svg xmlns="http://www.w3.org/2000/svg" width="{width_px}" viewBox="0 0 660 200" role="img" aria-label="iAPPs PADEL TOURNAMENT">  <defs>    <linearGradient id="g1" x1="0" y1="0" x2="1" y2="0">      <stop offset="0%" stop-color="{PRIMARY_BLUE}" />      <stop offset="100%" stop-color="{DARK_BLUE}" />    </linearGradient>  </defs>  <rect x="0" y="0" width="660" height="200" fill="transparent"/>  <text x="8" y="65" font-family="Inter, Segoe UI, Roboto, Arial, sans-serif" font-weight="800"        font-size="74" fill="url(#g1)" letter-spacing="2">iAPP</text>  <text x="445" y="65" font-family="Inter, Segoe UI, Roboto, Arial, sans-serif" font-weight="900"        font-size="72" fill="{LIME_GREEN}">s</text>  <text x="8" y="125" font-family="Inter, Segoe UI, Roboto, Arial, sans-serif" font-weight="800"        font-size="76" fill="{PRIMARY_BLUE}" letter-spacing="4">PADEL</text>  <text x="8" y="182" font-family="Inter, Segoe UI, Roboto, Arial, sans-serif" font-weight="700"        font-size="58" fill="{PRIMARY_BLUE}" letter-spacing="6">TOURNAMENT</text></svg>'''def render_brand_top_left():    svg = brand_svg(220)    st.markdown(        f'''        <style>        .brand-wrap {{            position: fixed;            top: 10px;            left: 14px;            z-index: 9999;        }}        @media (max-width: 860px) {{            .brand-wrap {{ transform: scale(0.85); transform-origin: top left; }}        }}        </style>        <div class="brand-wrap">{svg}</div>        ''',        unsafe_allow_html=True    )# ----------------------------# Carpetas y persistencia en JSON local# ----------------------------DATA_DIR = Path("data")USERS_PATH = DATA_DIR / "users.json"TOURN_DIR = DATA_DIR / "tournaments"SNAP_ROOT = TOURN_DIR / "snapshots"TOURN_INDEX = TOURN_DIR / "index.json"KEEP_SNAPSHOTS = 20DATA_DIR.mkdir(exist_ok=True)TOURN_DIR.mkdir(exist_ok=True)SNAP_ROOT.mkdir(parents=True, exist_ok=True)sha = lambda s: hashlib.sha256(s.encode("utf-8")).hexdigest()now_iso = lambda: datetime.now().isoformat()# ----------------------------# Usuarios (ADMIN, ADMINs de torneo y VIEWER)# ----------------------------DEFAULT_SUPER = {"username": "ADMIN", "pin_hash": sha("199601"), "role": "SUPER_ADMIN",                 "assigned_admin": None, "created_at": now_iso(), "active": True}def load_users() -> List[Dict[str, Any]]:    if not USERS_PATH.exists():        USERS_PATH.write_text(json.dumps([DEFAULT_SUPER], indent=2), encoding="utf-8")        return [DEFAULT_SUPER]    return json.loads(USERS_PATH.read_text(encoding="utf-8"))def save_users(users: List[Dict[str, Any]]):    USERS_PATH.write_text(json.dumps(users, ensure_ascii=False, indent=2), encoding="utf-8")def get_user(username: str) -> Optional[Dict[str, Any]]:    for u in load_users():        if u["username"].lower() == username.lower():            return u    return Nonedef set_user(user: Dict[str, Any]):    users = load_users()    for i, u in enumerate(users):        if u["username"].lower() == user["username"].lower():            users[i] = user            save_users(users)            return    users.append(user)    save_users(users)# ----------------------------# Torneos# ----------------------------def load_index() -> List[Dict[str, Any]]:    if not TOURN_INDEX.exists():        TOURN_INDEX.write_text("[]", encoding="utf-8")        return []    return json.loads(TOURN_INDEX.read_text(encoding="utf-8"))def save_index(idx: List[Dict[str, Any]]):    TOURN_INDEX.write_text(json.dumps(idx, ensure_ascii=False, indent=2), encoding="utf-8")def tourn_path(tid: str) -> Path:    return TOURN_DIR / f"{tid}.json"def snap_dir_for(tid: str) -> Path:    p = SNAP_ROOT / tid    p.mkdir(parents=True, exist_ok=True)    return pdef load_tournament(tid: str) -> Dict[str, Any]:    p = tourn_path(tid)    if not p.exists():        return {}    return json.loads(p.read_text(encoding="utf-8"))def save_tournament(tid: str, obj: Dict[str, Any], make_snapshot: bool=True):    p = tourn_path(tid)    p.write_text(json.dumps(obj, ensure_ascii=False, indent=2), encoding="utf-8")    if make_snapshot:        sd = snap_dir_for(tid)        ts = datetime.now().strftime("%Y%m%d_%H%M%S")        (sd / f"snapshot_{ts}.json").write_text(json.dumps(obj, ensure_ascii=False, indent=2), encoding="utf-8")        snaps = sorted([x for x in sd.glob("snapshot_*.json")], reverse=True)        for old in snaps[KEEP_SNAPSHOTS:]:            try: old.unlink()            except Exception: pass# ----------------------------# Reglas del torneo y lógica# ----------------------------DEFAULT_CONFIG = {    "t_name": "Open Pádel",    "num_pairs": 16,    "num_zones": 4,    "top_per_zone": 2,    "points_win": 2,    "points_draw": 1,    "points_loss": 0,    "seed": 42,    "format": "best_of_3"  # one_set | best_of_3 | best_of_5}rng = lambda off, seed: random.Random(int(seed) + int(off))def create_groups(pairs, num_groups, seed=42):    r = random.Random(int(seed))    shuffled = pairs[:]    r.shuffle(shuffled)    groups = [[] for _ in range(num_groups)]    for i, p in enumerate(shuffled):        groups[i % num_groups].append(p)    return groupsdef rr_schedule(group):    return list(combinations(group, 2))def build_fixtures(groups):    rows = []    if not groups: return []    for zi, group in enumerate(groups, start=1):        zone = f"Z{zi}"        for a, b in rr_schedule(group):            rows.append({                "zone": zone,                "pair1": a,                "pair2": b,                "sets": [],                "golden1": 0,                "golden2": 0            })    return rowsdef validate_sets(fmt: str, sets: List[Dict[str,int]]) -> Tuple[bool, str]:    n = len(sets)    if fmt == "one_set":        if n != 1: return False, "Formato a 1 set: debe haber exactamente 1 set."    elif fmt == "best_of_3":        if n < 2 or n > 3: return False, "Formato al mejor de 3: debe haber 2 o 3 sets."    elif fmt == "best_of_5":        if n < 3 or n > 5: return False, "Formato al mejor de 5: debe haber entre 3 y 5 sets."    return True, ""def compute_sets_stats(sets: List[Dict[str,int]]) -> Dict[str,int]:    g1=g2=s1=s2=0    for s in sets:        a = int(s.get("s1",0)); b = int(s.get("s2",0))        g1 += a; g2 += b        if a>b: s1 += 1        elif b>a: s2 += 1    return {"games1": g1, "games2": g2, "sets1": s1, "sets2": s2}def standings_from_results(zone_name, group_pairs, results_list, cfg):    rows = [{"pair": p, "PJ": 0, "PG": 0, "PP": 0, "GF": 0, "GC": 0, "GP": 0, "PTS": 0} for p in group_pairs]    table = pd.DataFrame(rows).set_index("pair")    fmt = cfg.get("format","best_of_3")    for m in results_list:        if m["zone"] != zone_name: continue        sets = m.get("sets", [])        ok, _ = validate_sets(fmt, sets)        if not ok: continue        stats = compute_sets_stats(sets)        p1, p2 = m["pair1"], m["pair2"]        g1,g2 = stats["games1"], stats["games2"]        s1,s2 = stats["sets1"], stats["sets2"]        for p, gf, gc in [(p1,g1,g2),(p2,g2,g1)]:            table.at[p, "PJ"] += 1            table.at[p, "GF"] += gf            table.at[p, "GC"] += gc        table.at[p1, "GP"] += int(m.get("golden1",0))        table.at[p2, "GP"] += int(m.get("golden2",0))        if s1>s2:            table.at[p1, "PG"] += 1; table.at[p2, "PP"] += 1            table.at[p1, "PTS"] += cfg["points_win"]            table.at[p2, "PTS"] += cfg["points_loss"]        elif s2>s1:            table.at[p2, "PG"] += 1; table.at[p1, "PP"] += 1            table.at[p2, "PTS"] += cfg["points_win"]            table.at[p1, "PTS"] += cfg["points_loss"]        else:            table.at[p1, "PTS"] += cfg["points_draw"]            table.at[p2, "PTS"] += cfg["points_draw"]    table["DG"] = table["GF"] - table["GC"]    r = rng(0, cfg["seed"]) ; randmap = {p: r.random() for p in table.index}    table["RND"] = table.index.map(randmap.get)    table = table.sort_values(by=["PTS","DG","GP","RND"], ascending=[False,False,False,False]).reset_index()    table.insert(0, "Zona", zone_name)    table.insert(1, "Pos", range(1, len(table)+1))    return table.drop(columns=["RND"])def qualified_from_tables(zone_tables, k):    qualified = []    for table in zone_tables:        if table.empty: continue        z = table.iloc[0]["Zona"]        q = table.head(int(k))        for _, row in q.iterrows():            qualified.append((z, int(row["Pos"]), row["pair"]))    return qualifieddef cross_bracket(qualified):    winners = [(z, pos, p) for (z,pos,p) in qualified if pos==1]    runners = [(z, pos, p) for (z,pos,p) in qualified if pos==2]    if len(winners)==0 or len(runners)==0: return []    runners_rot = runners[1:] + runners[:1] if len(runners)>1 else runners    pairs = []    for w, r in zip(winners, runners_rot):        pairs.append((f"{w[0]}1", w[2], f"{r[0]}2", r[2]))    return pairsdef next_round(slots: List[str]):    out=[]; i=0    while i < len(slots):        if i+1 < len(slots): out.append((slots[i], slots[i+1])); i+=2        else: out.append((slots[i], None)); i+=1    return out# ----------------------------# Sesión# ----------------------------def init_session():    st.session_state.setdefault("auth_user", None)    st.session_state.setdefault("current_tid", None)    st.session_state.setdefault("autosave", True)    st.session_state.setdefault("last_hash", "")    st.session_state.setdefault("pdf_fixture_bytes", None)    st.session_state.setdefault("pdf_playoffs_bytes", None)    st.session_state.setdefault("pdf_generated_at", None)def compute_state_hash(state: Dict[str,Any]) -> str:    return hashlib.sha256(json.dumps(state, sort_keys=True, ensure_ascii=False).encode("utf-8")).hexdigest()def tournament_state_template(admin_username: str, meta: Dict[str, Any]) -> Dict[str, Any]:    cfg = DEFAULT_CONFIG.copy()    cfg["t_name"] = meta.get("t_name") or cfg["t_name"]    pairs = [f"Pareja {i+1}" for i in range(cfg["num_pairs"])]    return {        "meta": {            "tournament_id": meta["tournament_id"],            "t_name": cfg["t_name"],            "place": meta.get("place",""),            "date": meta.get("date",""),            "gender": meta.get("gender","mixto"),            "admin_username": admin_username,            "created_at": now_iso(),        },        "config": cfg,        "pairs": pairs,        "groups": None,        "results": [],  # {zone,pair1,pair2,sets[],golden1,golden2}        "ko": {"matches": []},  # llaves eliminatorias    }# ----------------------------# Login# ----------------------------def login_form():    st.markdown("""    ### Ingreso    Usuario + PIN (6 dígitos)    """)    with st.form("login"):        username = st.text_input("Usuario").strip()        pin = st.text_input("PIN (6 dígitos)", type="password").strip()        submitted = st.form_submit_button("Ingresar", type="primary")    if submitted:        user = get_user(username)        if not user or not user.get("active", True):            st.error("Usuario inexistente o inactivo.") ; return        if len(pin)!=6 or not pin.isdigit():            st.error("PIN inválido.") ; return        if sha(pin) != user["pin_hash"]:            st.error("PIN incorrecto.") ; return        st.session_state.auth_user = user        st.success(f"Bienvenido {user['username']} ({user['role']})")# ----------------------------# Panel del SUPER_ADMIN# ----------------------------def super_admin_panel():    render_brand_top_left()    st.header("Panel de ADMIN (Super Admin)")    users = load_users()    with st.expander("? Crear usuario"):        c1,c2,c3 = st.columns(3)        with c1: u = st.text_input("Username nuevo").strip()        with c2: role = st.selectbox("Rol", ["TOURNAMENT_ADMIN","VIEWER"])        with c3: pin = st.text_input("PIN inicial (6)", max_chars=6).strip()        assigned_admin=None        if role=="VIEWER":            admins=[x["username"] for x in users if x["role"]=="TOURNAMENT_ADMIN" and x.get("active",True)]            assigned_admin = st.selectbox("Asignar a admin", admins) if admins else None        if st.button("Crear usuario", type="primary"):            if not u: st.error("Username requerido.")            elif get_user(u): st.error("Ya existe.")            elif len(pin)!=6 or not pin.isdigit(): st.error("PIN inválido.")            else:                set_user({"username":u,"pin_hash":sha(pin),"role":role,"assigned_admin":assigned_admin,"created_at":now_iso(),"active":True})                st.success(f"Usuario {u} creado.")    st.subheader("Usuarios")    for usr in users:        with st.container(border=True):            st.write(f"**{usr['username']}** — rol `{usr['role']}` — activo `{usr.get('active',True)}`")            c1,c2,c3,c4 = st.columns(4)            with c1:                if st.button(f"Reset PIN: {usr['username']}", key=f"rst_{usr['username']}"):                    new_pin = st.text_input(f"Nuevo PIN para {usr['username']}", key=f"np_{usr['username']}", max_chars=6)                    if new_pin and new_pin.isdigit() and len(new_pin)==6:                        usr["pin_hash"] = sha(new_pin); set_user(usr); st.success("PIN actualizado.")            with c2:                if usr["role"]=="VIEWER":                    admins=[x["username"] for x in users if x["role"]=="TOURNAMENT_ADMIN" and x.get("active",True)]                    new_admin = st.selectbox(f"Admin de {usr['username']}", admins+[None], key=f"adm_{usr['username']}")                    if st.button(f"Guardar admin {usr['username']}", key=f"sadm_{usr['username']}"):                        usr["assigned_admin"]=new_admin; set_user(usr); st.success("Asignado.")            with c3:                active_toggle = st.checkbox("Activo", value=usr.get("active",True), key=f"act_{usr['username']}")                if st.button(f"Guardar activo {usr['username']}", key=f"sact_{usr['username']}"):                    usr["active"]=active_toggle; set_user(usr); st.success("Estado guardado.")            with c4:                if usr["username"]!="ADMIN" and st.button(f"Inactivar {usr['username']}", key=f"del_{usr['username']}"):                    usr["active"] = False; set_user(usr); st.success("Inactivado.")# ----------------------------# Área del ADMIN de Torneo# ----------------------------def load_index_for_admin(admin_username: str) -> List[Dict[str, Any]]:    idx = load_index()    my = [t for t in idx if t.get("admin_username")==admin_username]    def keyf(t):        try: return datetime.fromisoformat(t.get("date"))        except Exception: return datetime.min    return sorted(my, key=keyf, reverse=True)def create_tournament(admin_username: str, t_name: str, place: str, tdate: str, gender: str) -> str:    tid = str(uuid.uuid4())[:8]    meta = {"tournament_id":tid,"t_name":t_name,"place":place,"date":tdate,"gender":gender}    state = tournament_state_template(admin_username, meta)    save_tournament(tid, state)    idx = load_index(); idx.append({"tournament_id":tid,"t_name":t_name,"place":place,"date":tdate,"gender":gender,"admin_username":admin_username,"created_at":now_iso()})    save_index(idx)    return tiddef delete_tournament(admin_username: str, tid: str):    idx = load_index(); idx = [t for t in idx if not (t["tournament_id"]==tid and t["admin_username"]==admin_username)]    save_index(idx)    p = tourn_path(tid)    if p.exists(): p.unlink()    for f in (snap_dir_for(tid)).glob("*.json"):        try: f.unlink()        except Exception: passdef admin_dashboard(user: Dict[str, Any]):    render_brand_top_left()    st.header(f"Torneos de {user['username']}")    with st.expander("? Crear torneo nuevo", expanded=True):        c1,c2,c3,c4 = st.columns(4)        with c1: t_name = st.text_input("Nombre del torneo", value="Open Pádel")        with c2: place = st.text_input("Lugar / Club", value="Mi Club")        with c3: tdate = st.date_input("Fecha", value=date.today()).isoformat()        with c4: gender = st.selectbox("Género", ["masculino","femenino","mixto"], index=2)        if st.button("Crear torneo", type="primary"):            tid = create_tournament(user["username"], t_name, place, tdate, gender)            st.session_state.current_tid = tid            st.success(f"Torneo creado: {t_name} ({tid})")    my = load_index_for_admin(user["username"])    if not my: st.info("Aún no tienes torneos."); return    st.subheader("Abrir / eliminar torneo")    names = [f"{t['date']} — {t['t_name']} ({t['gender']}) — {t['place']} — ID:{t['tournament_id']}" for t in my]    selected = st.selectbox("Selecciona un torneo", names, index=0)    sel = my[names.index(selected)]    c1,c2,c3 = st.columns(3)    with c1:        if st.button("Abrir torneo"): st.session_state.current_tid = sel["tournament_id"]    with c2:        if st.button("Eliminar torneo", type="secondary"):            delete_tournament(user["username"], sel["tournament_id"])            st.success("Torneo eliminado.")            if st.session_state.get("current_tid")==sel["tournament_id"]:                st.session_state.current_tid=None    with c3:        tid = sel["tournament_id"]        st.caption("Link público (solo lectura):")        st.code(f"?mode=public&tid={tid}")    if st.session_state.get("current_tid"): tournament_manager(user, st.session_state["current_tid"])# ----------------------------# Viewer (consulta)# ----------------------------def viewer_dashboard(user: Dict[str, Any]):    render_brand_top_left()    st.header(f"Vista de consulta — {user['username']}")    if not user.get("assigned_admin"): st.warning("No asignado a un admin."); return    my = load_index_for_admin(user["assigned_admin"])    if not my: st.info("El admin asignado no tiene torneos."); return    names = [f"{t['date']} — {t['t_name']} ({t['gender']}) — {t['place']} — ID:{t['tournament_id']}" for t in my]    selected = st.selectbox("Selecciona un torneo para ver", names, index=0)    sel = my[names.index(selected)]    viewer_tournament(sel["tournament_id"])# ----------------------------# Gestor del Torneo (Admin)# ----------------------------def tournament_manager(user: Dict[str, Any], tid: str):    render_brand_top_left()    state = load_tournament(tid)    if not state: st.error("No se encontró el torneo."); return    tab_cfg, tab_pairs, tab_results, tab_tables, tab_ko, tab_persist = st.tabs(        ["?? Configuración", "?? Parejas", "?? Resultados", "?? Tablas", "??? Playoffs", "?? Persistencia"]    )    cfg = state.get("config", DEFAULT_CONFIG.copy())    # CONFIG    with tab_cfg:        st.subheader("Datos del torneo")        m = state.get("meta", {})        st.write({"ID":m.get("tournament_id"),"Nombre":m.get("t_name"),"Lugar":m.get("place"),"Fecha":m.get("date"),"Género":m.get("gender"),"Admin":m.get("admin_username")})        st.subheader("Configuración deportiva")        c1,c2,c3,c4 = st.columns(4)        with c1:            cfg["t_name"] = st.text_input("Nombre para mostrar", value=cfg.get("t_name","Open Pádel"))            cfg["num_pairs"] = st.number_input("Cantidad total de parejas", 4, 256, int(cfg.get("num_pairs",16)), step=2)        with c2:            cfg["num_zones"] = st.number_input("Cantidad de zonas", 2, 32, int(cfg.get("num_zones",4)), step=1)            cfg["top_per_zone"] = st.number_input("Clasifican por zona (Top N)", 1, 8, int(cfg.get("top_per_zone",2)), step=1)        with c3:            cfg["points_win"] = st.number_input("Puntos por victoria", 1, 10, int(cfg.get("points_win",2)), step=1)            cfg["points_draw"] = st.number_input("Puntos por empate", 0, 10, int(cfg.get("points_draw",1)), step=1)        with c4:            cfg["points_loss"] = st.number_input("Puntos por derrota", 0, 5, int(cfg.get("points_loss",0)), step=1)            cfg["seed"] = st.number_input("Semilla", 1, 999999, int(cfg.get("seed",42)), step=1)        fmt = st.selectbox("Formato de partido", ["one_set","best_of_3","best_of_5"], index=["one_set","best_of_3","best_of_5"].index(cfg.get("format","best_of_3")))        cfg["format"] = fmt        cA,cB,cC = st.columns(3)        with cA:            if st.button("?? Guardar configuración", type="primary"):                state["config"] = {k:int(v) if isinstance(v,(int,float)) and k not in ["t_name"] else v for k,v in cfg.items()}                save_tournament(tid, state)                st.success("Configuración guardada.")        with cB:            if st.button("?? Re-sortear zonas"):                pairs = state.get("pairs", [])                groups = create_groups(pairs, int(cfg["num_zones"]), seed=int(cfg["seed"]))                state["groups"] = groups                state["results"] = build_fixtures(groups)                save_tournament(tid, state)                st.info("Zonas regeneradas.")        with cC:            if REPORTLAB_OK and st.button("?? Generar PDFs"):                with st.spinner("Generando PDFs..."):                    buf1 = export_fixture_pdf(state)                    buf2 = export_playoffs_pdf(state)                if buf1: st.session_state.pdf_fixture_bytes = buf1.getvalue()                if buf2: st.session_state.pdf_playoffs_bytes = buf2.getvalue()                st.session_state.pdf_generated_at = datetime.now().strftime("%Y-%m-%d %H:%M:%S")                st.success("PDFs generados. Descarga abajo.")            elif not REPORTLAB_OK:                st.info("Para PDF: pip install reportlab")        if st.session_state.pdf_fixture_bytes or st.session_state.pdf_playoffs_bytes:            st.markdown("#### Descargas de PDF")            st.caption(f"Generado: {st.session_state.pdf_generated_at or '-'}")            if st.session_state.pdf_fixture_bytes:                st.download_button("?? Fixture (PDF)",                                   data=st.session_state.pdf_fixture_bytes,                                   file_name=f"fixture_{state['meta']['tournament_id']}.pdf",                                   mime="application/pdf",                                   key="dl_fixture_pdf")            if st.session_state.pdf_playoffs_bytes:                st.download_button("?? Playoffs (PDF)",                                   data=st.session_state.pdf_playoffs_bytes,                                   file_name=f"playoffs_{state['meta']['tournament_id']}.pdf",                                   mime="application/pdf",                                   key="dl_playoffs_pdf")            if st.button("?? Limpiar PDFs generados"):                st.session_state.pdf_fixture_bytes = None                st.session_state.pdf_playoffs_bytes = None                st.session_state.pdf_generated_at = None                st.success("Limpio.")    # PAREJAS    with tab_pairs:        st.subheader("Parejas")        pairs_text = st.text_area("Pegá/edita las parejas (una por línea)", value="\n".join(state.get("pairs", [])), height=260)        c1,c2 = st.columns(2)        with c1:            if st.button("?? Guardar parejas"):                parsed = [p.strip() for p in pairs_text.splitlines() if p.strip()]                state["pairs"] = parsed                state["config"]["num_pairs"] = len(parsed)                save_tournament(tid, state)                st.success(f"Guardadas {len(parsed)} parejas.")        with c2:            if st.button("?? Sortear zonas (crear fixture)"):                cfg = state["config"]                groups = create_groups(state["pairs"], int(cfg["num_zones"]), seed=int(cfg["seed"]))                state["groups"] = groups                state["results"] = build_fixtures(groups)                save_tournament(tid, state)                st.success("Zonas creadas y fixture generado.")        if state.get("groups"):            st.divider(); st.markdown("### Zonas")            for zi, group in enumerate(state["groups"], start=1):                st.write(f"**Z{zi}**")                st.table(pd.DataFrame({"Parejas": group}))    # RESULTADOS    with tab_results:        st.subheader("Resultados — fase de grupos (sets + puntos de oro)")        if not state.get("groups"):            st.info("Primero crea/sortea zonas.")        else:            fmt = state["config"].get("format","best_of_3")            zones = sorted({m["zone"] for m in state["results"]})            z_filter = st.selectbox("Filtrar por zona", ["(todas)"] + zones)            pnames = sorted(set([m["pair1"] for m in state["results"]] + [m["pair2"] for m in state["results"]]))            p_filter = st.selectbox("Filtrar por pareja", ["(todas)"] + pnames)            listing = state["results"]            if z_filter != "(todas)": listing = [m for m in listing if m["zone"]==z_filter]            if p_filter != "(todas)": listing = [m for m in listing if m["pair1"]==p_filter or m["pair2"]==p_filter]            for m in listing:                idx = state["results"].index(m)                with st.container(border=True):                    st.write(f"**{m['zone']}** — {m['pair1']} vs {m['pair2']}")                    cur_sets = m.get("sets", [])                    n_min, n_max = (1,1) if fmt=="one_set" else ((2,3) if fmt=="best_of_3" else (3,5))                    n_sets = st.number_input("Sets jugados", min_value=n_min, max_value=n_max, value=min(max(len(cur_sets), n_min), n_max), key=f"ns_{tid}_{idx}")                    new_sets = []                    for si in range(n_sets):                        cA,cB = st.columns(2)                        with cA:                            s1 = st.number_input(f"Set {si+1} — games {m['pair1']}", 0, 20, int(cur_sets[si]["s1"]) if si<len(cur_sets) and "s1" in cur_sets[si] else 0, key=f"s1_{tid}_{idx}_{si}")                        with cB:                            s2 = st.number_input(f"Set {si+1} — games {m['pair2']}", 0, 20, int(cur_sets[si]["s2"]) if si<len(cur_sets) and "s2" in cur_sets[si] else 0, key=f"s2_{tid}_{idx}_{si}")                        new_sets.append({"s1":int(s1),"s2":int(s2)})                    ok, msg = validate_sets(fmt, new_sets)                    if not ok: st.error(msg)                    gC,gD = st.columns(2)                    with gC:                        g1 = st.number_input(f"Puntos de oro {m['pair1']}", 0, 200, int(m.get("golden1",0)), key=f"g1_{tid}_{idx}")                    with gD:                        g2 = st.number_input(f"Puntos de oro {m['pair2']}", 0, 200, int(m.get("golden2",0)), key=f"g2_{tid}_{idx}")                    if st.button("Guardar partido", key=f"sv_{tid}_{idx}"):                        state["results"][idx]["sets"] = new_sets                        state["results"][idx]["golden1"] = int(g1)                        state["results"][idx]["golden2"] = int(g2)                        save_tournament(tid, state)                        st.success("Partido guardado.")    # TABLAS    with tab_tables:        st.subheader("Tablas por zona y clasificados")        if not state.get("groups") or not state.get("results"):            st.info("Aún no hay fixture o resultados.")        else:            cfg = state["config"]            zone_tables = []            for zi, group in enumerate(state["groups"], start=1):                zone_name = f"Z{zi}"                table = standings_from_results(zone_name, group, state["results"], cfg)                zone_tables.append(table)                with st.expander(f"Tabla {zone_name}", expanded=True):                    st.dataframe(table, use_container_width=True)            qualified = qualified_from_tables(zone_tables, cfg["top_per_zone"])            st.markdown("### Clasificados a Playoffs")            if not qualified: st.info("Sin clasificados aún.")            else: st.table(pd.DataFrame([{"Zona":z,"Pos":pos,"Pareja":p} for (z,pos,p) in qualified]))    # PLAYOFFS    with tab_ko:        st.subheader("Playoffs (por sets + puntos de oro)")        if not state.get("groups") or not state.get("results"):            st.info("Necesitas tener zonas y resultados para definir clasificados.")        else:            cfg = state["config"]; fmt = cfg.get("format","best_of_3")            zone_tables = []            for zi, group in enumerate(state["groups"], start=1):                zone_name = f"Z{zi}"`                table = standings_from_results(zone_name, group, state["results"], cfg)                zone_tables.append(table)            qualified = qualified_from_tables(zone_tables, cfg["top_per_zone"])            if len(qualified) < 2:                st.info("Se requieren al menos dos zonas con clasificados.")            else:                initial = cross_bracket(qualified)                st.markdown("#### Cruces iniciales")                if not state["ko"]["matches"]:                    for i,(tagA,a,tagB,b) in enumerate(initial, start=1):                        state["ko"]["matches"].append({                            "round": "QF","label": f"QF{i}","a": a,"b": b,                            "sets": [],"goldenA": 0,"goldenB": 0                        })                    save_tournament(tid, state)                round_names = ["QF","SF","FN"]                for rname in round_names:                    ms = [m for m in state["ko"]["matches"] if m["round"]==rname]                    if not ms: continue                    st.markdown(f"### {rname}")                    advancing = []                    for idx, m in enumerate(ms, start=1):                        with st.container(border=True):                            st.write(f"**{m['label']}** — {m['a']} vs {m['b']}")                            cur_sets = m.get("sets", [])                            n_min, n_max = (1,1) if fmt=="one_set" else ((2,3) if fmt=="best_of_3" else (3,5))                            n_sets = st.number_input("Sets jugados", min_value=n_min, max_value=n_max, value=min(max(len(cur_sets), n_min), n_max), key=f"ko_ns_{tid}_{rname}_{idx}")                            new_sets = []                            for si in range(n_sets):                                cA,cB = st.columns(2)                                with cA:                                    s1 = st.number_input(f"Set {si+1} — games {m['a']}", 0, 20, int(cur_sets[si]["s1"]) if si<len(cur_sets) and "s1" in cur_sets[si] else 0, key=f"ko_s1_{tid}_{rname}_{idx}_{si}")                                with cB:                                    s2 = st.number_input(f"Set {si+1} — games {m['b']}", 0, 20, int(cur_sets[si]["s2"]) if si<len(cur_sets) and "s2" in cur_sets[si] else 0, key=f"ko_s2_{tid}_{rname}_{idx}_{si}")                                new_sets.append({"s1":int(s1),"s2":int(s2)})                            ok, msg = validate_sets(fmt, new_sets)                            if not ok: st.error(msg)                            gC,gD = st.columns(2)                            with gC:                                g1 = st.number_input(f"Puntos de oro {m['a']}", 0, 200, int(m.get("goldenA",0)), key=f"ko_g1_{tid}_{rname}_{idx}")                            with gD:                                g2 = st.number_input(f"Puntos de oro {m['b']}", 0, 200, int(m.get("goldenB",0)), key=f"ko_g2_{tid}_{rname}_{idx}")                            if st.button("Guardar partido KO", key=f"ko_sv_{tid}_{rname}_{idx}"):                                m["sets"] = new_sets; m["goldenA"] = int(g1); m["goldenB"] = int(g2)                                save_tournament(tid, state); st.success("KO guardado.")                            stats = compute_sets_stats(new_sets)                            if stats["sets1"] == stats["sets2"]:                                rr = rng(9000+idx, cfg["seed"]); winner = rr.choice([m['a'], m['b']])                                st.caption(f"Empate en sets ? sorteo: **{winner}**")                            else:                                winner = m['a'] if stats["sets1"]>stats["sets2"] else m['b']                                st.caption(f"Ganador: **{winner}**")                            advancing.append(winner)                    if rname != "FN" and advancing:                        pairs = next_round(advancing)                        next_r = "SF" if rname=="QF" else "FN"                        existing = [m for m in state["ko"]["matches"] if m["round"]==next_r]                        labels = ["SF1","SF2"] if next_r=="SF" else ["FINAL"]                        if not existing:                            for j,(a,b) in enumerate(pairs, start=1):                                state["ko"]["matches"].append({                                    "round": next_r, "label": labels[min(j-1,len(labels)-1)],                                    "a": a, "b": (b or "BYE"), "sets": [], "goldenA": 0, "goldenB": 0                                })                            save_tournament(tid, state)    # PERSISTENCIA    with tab_persist:        st.subheader("Persistencia (autosave + snapshots)")        c1,c2,c3,c4 = st.columns(4)        with c1: st.session_state.autosave = st.checkbox("Autosave", value=st.session_state.autosave)        with c2:            if st.button("?? Guardar ahora"): save_tournament(tid, state); st.success("Guardado")        with c3:            st.download_button("?? Descargar estado (JSON)", data=json.dumps(state, ensure_ascii=False, indent=2).encode("utf-8"), file_name=f"{tid}.json", mime="application/json")        with c4:            up = st.file_uploader("?? Cargar estado", type=["json"], key=f"up_{tid}")            if up is not None:                try:                    new_state = json.load(up); save_tournament(tid, new_state); st.success("Cargado y guardado.")                except Exception as e:                    st.error(f"Error al cargar: {e}")    current_hash = compute_state_hash(state)    if st.session_state.autosave and current_hash != st.session_state.last_hash:        save_tournament(tid, state)        st.toast("?? Autosaved", icon="??")        st.session_state.last_hash = current_hash    elif not st.session_state.autosave:        st.session_state.last_hash = current_hash# ----------------------------# Viewer (público o perfil VIEWER)# ----------------------------def viewer_tournament(tid: str, public: bool=False):    render_brand_top_left()    state = load_tournament(tid)    if not state:        st.error("No se encontró el torneo."); return    st.subheader(f"{state['meta'].get('t_name')} — {state['meta'].get('place']} — {state['meta'].get('date')} — {state['meta'].get('gender')}")    tab_over, tab_tables, tab_ko = st.tabs(["?? General","?? Tablas","?? Playoffs"])    with tab_over:        st.write("Parejas"); st.table(pd.DataFrame({"Parejas": state.get("pairs", [])}))        if state.get("groups"):            st.write("Zonas")            for zi, group in enumerate(state["groups"], start=1):                st.write(f"**Z{zi}**"); st.table(pd.DataFrame({"Parejas": group}))    with tab_tables:        if not state.get("groups") or not state.get("results"):            st.info("Sin fixture/resultados aún.")        else:            cfg = state["config"]            for zi, group in enumerate(state["groups"], start=1):                zone_name = f"Z{zi}"                table = standings_from_results(zone_name, group, state["results"], cfg)                with st.expander(f"Tabla {zone_name}", expanded=True): st.dataframe(table, use_container_width=True)    with tab_ko:        st.json(state.get("ko", {}))    if public: st.info("Modo público (solo lectura)")# ----------------------------# Exportación de PDF# ----------------------------def export_fixture_pdf(state: Dict[str,Any]) -> Optional[BytesIO]:    if not REPORTLAB_OK: return None    buf = BytesIO()    doc = SimpleDocTemplate(buf, pagesize=A4, leftMargin=1.5*cm, rightMargin=1.5*cm, topMargin=1.5*cm, bottomMargin=1.5*cm)    styles = getSampleStyleSheet()    elems = []    title = f"Fixture — {state['meta'].get('t_name')} — {state['meta'].get('place')} — {state['meta'].get('date')}"    elems.append(Paragraph(title, styles['Title']))    elems.append(Spacer(1, 12))    if not state.get("groups"):        elems.append(Paragraph("Sin zonas generadas.", styles['Normal']))    else:        for zi, group in enumerate(state["groups"], start=1):            elems.append(Paragraph(f"Zona Z{zi}", styles['Heading2']))            data = [["Parejas"]] + [[p] for p in group]            t = Table(data, colWidths=[16*cm])            t.setStyle(TableStyle([('GRID',(0,0),(-1,-1),0.5,colors.grey),('BACKGROUND',(0,0),(-1,0),colors.lightgrey)]))            elems.append(t); elems.append(Spacer(1,8))        rows = [["Zona","Pareja 1","Pareja 2"]]        for m in state["results"]:            rows.append([m["zone"], m["pair1"], m["pair2"]])        elems.append(Paragraph("Partidos (fase de grupos)", styles['Heading2']))        t2 = Table(rows, colWidths=[2*cm, 7*cm, 7*cm])        t2.setStyle(TableStyle([('GRID',(0,0),(-1,-1),0.5,colors.grey),('BACKGROUND',(0,0),(-1,0),colors.lightgrey)]))        elems.append(t2)    doc.build(elems)    buf.seek(0)    return bufdef export_playoffs_pdf(state: Dict[str,Any]) -> Optional[BytesIO]:    if not REPORTLAB_OK: return None    buf = BytesIO()    doc = SimpleDocTemplate(buf, pagesize=A4, leftMargin=1.0*cm, rightMargin=1.0*cm, topMargin=1.0*cm, bottomMargin=1.0*cm)    styles = getSampleStyleSheet()    elems = []    elems.append(Paragraph(f"Playoffs — {state['meta'].get('t_name')}", styles['Title']))    elems.append(Spacer(1, 10))    ko = state.get("ko", {"matches": []})    rounds = ["QF","SF","FN"]    for r in rounds:        ms = [m for m in ko.get("matches", []) if m.get("round")==r]        if not ms: continue        elems.append(Paragraph(r, styles['Heading2']))        rows = [["Clave","A","B","Sets A-B","Ptos Oro A-B"]]        for m in ms:            stats = compute_sets_stats(m.get("sets", []))            sets_str = f"{stats['sets1']}-{stats['sets2']}"            gp_str = f"{m.get('goldenA',0)}-{m.get('goldenB',0)}"            rows.append([m.get("label",""), m.get("a",""), m.get("b",""), sets_str, gp_str])        t = Table(rows, colWidths=[3*cm, 5*cm, 5*cm, 3*cm, 3*cm])        t.setStyle(TableStyle([('GRID',(0,0),(-1,-1),0.5,colors.grey),('BACKGROUND',(0,0),(-1,0),colors.lightgrey)]))        elems.append(t); elems.append(Spacer(1,8))    doc.build(elems)    buf.seek(0)    return buf# ----------------------------# Entrada de la App# ----------------------------def init_app():    # Compatibilidad: obtener query params tanto en versiones nuevas como antiguas de Streamlit    if hasattr(st, "query_params"):        params = st.query_params    else:        params = st.experimental_get_query_params()    init_session()    mode = params.get("mode", [""])    mode = mode[0] if isinstance(mode, list) else mode    _tid = params.get("tid", [""])    _tid = _tid[0] if isinstance(_tid, list) else _tid    render_brand_top_left()    if mode=="public" and _tid:        viewer_tournament(_tid, public=True)    else:        if not st.session_state.get("auth_user"):            login_form()        else:            user = st.session_state["auth_user"]            top = st.columns([4,3,3,1])            with top[0]: st.markdown(f"**Usuario:** {user['username']} · Rol: `{user['role']}`")            with top[1]: st.link_button("Abrir Super Admin", url="?mode=super")            with top[2]: st.button("Cerrar sesión", on_click=lambda: st.session_state.update({"auth_user":None,"current_tid":None}))            st.divider()            if user["role"]=="SUPER_ADMIN" and (mode=="super"):                super_admin_panel()            elif user["role"]=="SUPER_ADMIN":                super_admin_panel()            elif user["role"]=="TOURNAMENT_ADMIN":                admin_dashboard(user)            elif user["role"]=="VIEWER":                viewer_dashboard(user)            else:                st.error("Rol desconocido.")st.caption("v3.3 — Correcciones sintácticas + logo iAPPs/PADEL/TOURNAMENT + descargas PDF robustas + KO por sets/GP + autosave.")init_app()